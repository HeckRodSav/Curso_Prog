\chapter{Procedimentos e funções}\label{cap.functions}

Ao longo do desenvolvimento de programas, não é difícil notar que alguns conjuntos de comandos se repetem ao longo do código.
Comandos usuais como exibir valores na tela, ler entradas do usuário, fazer conjuntos de contas ou validar valores lidos costumam ocorrer em muitos pontos do programa.
Assim como no caso das estruturas de repetição, não vale a pena copiar blocos de código pelos mesmos fatores, como alterações posteriores, busca de erros, etc.

Para evitar a necessidade cópias desnecessária, melhorar a legitibilidade, faciliar a busca por erros e a manutenção posterior do códigos foram desenvolvidos os procedimentos e as funções.
Eles consistem em blocos de código que recebem nomes próprios (assim como variáveis), e podem ser invocados em qualquer parte do programa.

Procedimentos e funções devem ser declarados de maneira global e antes de serem invocadas.
Podem interagir com variáveis globais e locais (de seus blocos).
Diferente dos controles de fluxo, necessariamente há um bloco de código associado.

Os mais simples são os procedimentos sem argumentos, sem valores de retorno, sem características especiais.e
Simplesmente são blocos de código com nome próprio que podem ser invocados.

\section{Procedimentos}

	Sua estrutura é tão simples que a apresentação da sintaxe direta serve para entender sua declaração.
	Lembrando que todo bloco pode contar com controladores de fluxo.
	O código \ref{code.functions.foo.void.sintax} apresenta a sintaxe básica de um procedimento chamado \basicCode{foo}.

	Os principais detalhes são: o tipo \basicCode{void}, a declaração global e os parênteses (\basicCode{()}) após o nome.
	Estes parênteses definem a declaração tipo \basicCode{void} como procedimento.

	\lstinputlisting[caption={Sintaxe básica de procedimento sem argumentos}, label=code.functions.foo.void.sintax]{../code/functions/foo.void.sintax.cpp}

	O código \ref{code.functions.foo.void.example} mostra um programa completo que calcula o MDC entre duas variáveis utilizando um procedimento chamado \basicCode{MCDab}.
	Note como os valores das variáveis são alterados pelo procedimento, isso pode gerar problemas no código.

	\lstinputlisting[caption={Exemplo de procedimento sem argumentos}, label=code.functions.foo.void.example]{../code/functions/foo.void.example.cpp}

	Vale ressaltar que, da maneira que está escrito, o algoritimo de Euclides depende que a variável \basicCode{A} seja a de maior valor.
	Procedimentos que rebebem argumentos facilitam situações como estas.

\section{Passagem de argumentos}

	Procedimentos podem receber valores de variáveis para seus blocos, através de variáveis auxiliares, que copiam os valores passados aos argumentos.
	Tais variáveis são ditas os \emph{parâmetros} do procedimento (ou da função).
	Estas variáveis devem ter o tipo definido, e os argumentos debem ser passados conforme o tipo.
	Múltiplos argumentos de multiplos tipos podem ser utilizado por procedimento, porém a ordem de passagem de argumentos deve ser respeitada.

	Os argumentos são como variáveis declaradas entre os parênteses do procedimento, que podem ser utilizadas em seu corpo.
	Estar variáveis reberão os valores passados no invocamento do procedimento durante o código princial.
	Cada argumento precisa ser separado por vírgulas, incluisive seus tipos.
	A sintaxe geral é apresentada no código \ref{code.functions.foo.void.args.sintax}.

	\lstinputlisting[caption={Sintaxe básica de procedimento com $N$ argumentos}, label=code.functions.foo.void.args.sintax]{../code/functions/foo.void.args.sintax.cpp}

	Lembrando sempre: respeitar a ordem de declaração, o código \ref{code.functions.foo.void.args.example} apresenta o mesmo algoritimo de Euclides, num procedimento com passagem de argumentos.

	\lstinputlisting[caption={Exemplo de procedimento com argumentos}, label=code.functions.foo.void.args.example]{../code/functions/foo.void.args.example.cpp}

	Note que, mesmo com a passagem de argumentos para o procedimento, o retorno ainda é feito por uma variável global, o que pode ser inconveniente em muitos casos.
	Se o procedimento pudesse ser usado como variável, seria muito mais simples.

	Isso é possível, e o procedimento que devolve um valor é chamado de \emph{função}.

\section{Funções}

	Assim como um procedimento, uma função pode ser invocada em qualquer lugar do código, a diferença é que neste lugar haverá o retorno de um valor (como os operadores, que retornam o valor da operação), então o valor retornado pode ser utilizado em uma operação, assim como uma variável.
	A função é declarada utilizando o tipo de seu retorno, então se uma função deve retornar um valor tipo \basicCode{int}, deve ser declarada como \basicCode{int}.

	Assim como o procedimento, a função tem um nome próprio, e pode receber argumentos.
	A sintaze geral de declaração de uma função com argumento é apresentada no código \ref{code.functions.foo.void.args.sintax}.
	Lembrando que, assim como no procedimento, os argumentos são opcionais.

	O detalhe importante sobre a função é a necessidade de um retorno: toda função deve apresentar a palavra-chave \basicCode{return}, seguida do valor a ser retornado.
	Vale notar que o \basicCode{return} pode ser encarado como um controle de fluxo, uma vez que ele retorna da função o valor dado, independende do lugar que for encontrado pelo fluxo, saindo da função.

	\lstinputlisting[caption={Sintaxe básica de função com $N$ argumentos}, label=code.functions.foo.type.args.sintax]{../code/functions/foo.type.args.sintax.cpp}

	A mesma implementação do algoritmo de Euclides, porém utilizando uma função do tipo \basicCode{int} é apresentada no código \ref{code.functions.foo.type.args.example}

	\lstinputlisting[caption={Exemplo de função com argumentos}, label=code.functions.foo.type.args.example]{../code/functions/foo.type.args.example.cpp}

	Vale notar que a funão \basicCode{main} é do tipo \basicCode{int}, e tem o retorno em \basicCode{0}, este valor informa ao sistema operacional que não houveram erros do programa.